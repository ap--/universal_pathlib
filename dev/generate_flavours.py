"""Generates


"""

from __future__ import annotations

import inspect
import re
from io import StringIO
from textwrap import shorten
from typing import Any

from fsspec.registry import available_protocols
from fsspec.registry import get_filesystem_class
from fsspec.spec import AbstractFileSystem
from fsspec.utils import get_package_version_without_import

HEADER = """\
# upath._flavour_sources.py
# This file is automatically generated by scripts/generate_flavours.py
# Do not modify this file manually...
#
"""

IMPORTS = """\
from __future__ import annotations

import logging
import re
from typing import Any
from typing import cast
from urllib.parse import parse_qs
from urllib.parse import urlsplit

from fsspec.implementations.local import make_path_posix
from fsspec.utils import infer_storage_options
from fsspec.utils import stringify_path

"""

INIT_CODE = '''\
__all__ = [
    "AbstractFileSystemFlavour",
    "FileSystemFlavourBase",
    "flavour_registry",
]

logger = logging.getLogger(__name__)
flavour_registry: dict[str, FileSystemFlavourBase] = {}


class FileSystemFlavourBase:
    """base class for the fsspec flavours"""

    def __init_subclass__(cls: Any, **kwargs):
        if isinstance(cls.protocol, str):
            protocols = (cls.protocol,)
        else:
            protocols = tuple(cls.protocol)
        for protocol in protocols:
            if protocol in flavour_registry:
                raise ValueError(f"protocol {protocol!r} already registered")
            flavour_registry[protocol] = cls
'''

BASE_CLASS_NAME_SUFFIX = "Flavour"
BASE_CLASS_NAME = f"{AbstractFileSystem.__name__}{BASE_CLASS_NAME_SUFFIX}"

FIX_METHODS = {
    "GCSFileSystem": ["_strip_protocol", "_get_kwargs_from_urls", "_split_path"],
}

FIX_SOURCE = {
    "AzureBlobFileSystem": lambda x: re.sub(
        r"host = ops.get\(\"host\", None\)",
        'host: str | None = ops.get("host", None)',
        x,
    )
}


def get_protos(cls: type, remove: str) -> tuple[str, ...]:
    if isinstance(cls.protocol, str):
        p = [cls.protocol]
    else:
        p = cls.protocol
    return tuple([x for x in p if x != remove])


def get_fsspec_filesystems_and_protocol_errors() -> (
    tuple[dict[type[AbstractFileSystem], tuple[str, ...]], dict[str, str]]
):
    classes: dict[type[AbstractFileSystem], tuple[str]] = {}
    errors: dict[str, str] = {}

    for protocol in available_protocols():
        try:
            cls = get_filesystem_class(protocol)
        except ImportError as err:
            errors[protocol] = str(err)
        else:
            protos = get_protos(cls, remove="abstract")
            cprotos = classes.get(cls, [])
            classes[cls] = tuple(dict.fromkeys([*cprotos, *protos, protocol]))
    return classes, errors


def get_subclass_methods(cls: type) -> list[str]:
    try:
        return FIX_METHODS[cls.__name__]
    except KeyError:
        pass
    try:
        so = cls._get_kwargs_from_urls is AbstractFileSystem._get_kwargs_from_urls
        sp = cls._strip_protocol.__func__ is AbstractFileSystem._strip_protocol.__func__
    except AttributeError:
        return []
    else:
        methods = []
        if not sp:
            methods.append("_strip_protocol")
        if not so:
            methods.append("_get_kwargs_from_urls")
        return methods


def generate_class_source_code(
    cls: type,
    methods: list[str],
    overrides: dict[str, Any],
    attributes: list[str],
    cls_suffix: str,
    base_cls: str | None,
) -> str:
    s = ["\n"]
    if base_cls:
        s += [f"class {cls.__name__}{cls_suffix}({base_cls}):"]
    else:
        s += [f"class {cls.__name__}{cls_suffix}:"]
    mod_ver = get_package_version_without_import(cls.__module__.partition(".")[0])
    s.append(f"    __orig_class__ = '{cls.__module__}.{cls.__name__}'")
    s.append(f"    __orig_version__ = {mod_ver!r}")
    for attr, value in overrides.items():
        s.append(f"    {attr} = {value!r}")
    for attr in attributes:
        s.append(f"    {attr} = {getattr(cls, attr)!r}")
    s.append("")
    for method in methods:
        s.append(inspect.getsource(getattr(cls, method)))
    try:
        fix_func = FIX_SOURCE[cls.__name__]
    except KeyError:
        return "\n".join(s)
    else:
        return "\n".join(fix_func(line) for line in s)


def create_source() -> str:
    buf = StringIO()
    buf.write(HEADER)

    classes, errors = get_fsspec_filesystems_and_protocol_errors()
    if errors:
        buf.write("# import errors:\n")
        for protocol, error_msg in sorted(errors.items()):
            buf.write(f"# - {protocol.ljust(12)} msg: {shorten(error_msg, width=60)}\n")
        buf.write("\n")

    buf.write(IMPORTS)
    buf.write(INIT_CODE)

    base_cls = generate_class_source_code(
        AbstractFileSystem,
        ["_strip_protocol", "_get_kwargs_from_urls"],
        {},
        ["protocol", "root_marker"],
        cls_suffix=BASE_CLASS_NAME_SUFFIX,
        base_cls="FileSystemFlavourBase",
    )
    buf.write(base_cls)

    for cls in sorted(classes, key=lambda cls: cls.__name__):
        sub_cls = generate_class_source_code(
            cls,
            get_subclass_methods(cls),
            {"protocol": classes[cls]},
            ["root_marker"],
            cls_suffix=BASE_CLASS_NAME_SUFFIX,
            base_cls=BASE_CLASS_NAME,
        )
        buf.write(sub_cls)

    return buf.getvalue().removesuffix("\n")


if __name__ == "__main__":
    print(create_source())
