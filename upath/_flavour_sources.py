# upath._flavour_sources.py
# This file is automatically generated by scripts/generate_flavours.py
# Do not modify this file manually...
#
# import errors:
# - asynclocal   msg: Install 'morefs[asynclocalfs]' to use AsyncLocalFileSystem
# - box          msg: Please install boxfs to access BoxFileSystem
# - dask         msg: Install dask distributed to access worker file system
# - dropbox      msg: DropboxFileSystem requires "dropboxdrivefs","requests" [...]
# - dvc          msg: Install dvc to access DVCFileSystem
# - gdrive       msg: Please install gdrivefs for access to Google Drive
# - git          msg: Install pygit2 to browse local git repos
# - hf           msg: Install huggingface_hub to access HfFileSystem
# - lakefs       msg: Please install lakefs-spec to access LakeFSFileSystem
# - libarchive   msg: LibArchive requires to be installed
# - oci          msg: Install ocifs to access OCI Object Storage
# - ocilake      msg: Install ocifs to access OCI Data Lake
# - oss          msg: Install ossfs to access Alibaba Object Storage System
# - root         msg: Install fsspec-xrootd to access xrootd storage system. [...]
# - sftp         msg: SFTPFileSystem requires "paramiko" to be installed
# - smb          msg: SMB requires "smbprotocol" or "smbprotocol[kerberos]" [...]
# - ssh          msg: SFTPFileSystem requires "paramiko" to be installed
# - wandb        msg: Install wandbfs to access wandb

from __future__ import annotations

import logging
import re
from typing import Any
from typing import cast
from urllib.parse import parse_qs
from urllib.parse import urlsplit

from fsspec.implementations.local import make_path_posix
from fsspec.utils import infer_storage_options
from fsspec.utils import stringify_path

__all__ = [
    "AbstractFileSystemFlavour",
    "FileSystemFlavourBase",
    "flavour_registry",
]

logger = logging.getLogger(__name__)
flavour_registry: dict[str, FileSystemFlavourBase] = {}


class FileSystemFlavourBase:
    """base class for the fsspec flavours"""

    def __init_subclass__(cls: Any, **kwargs):
        if isinstance(cls.protocol, str):
            protocols = (cls.protocol,)
        else:
            protocols = tuple(cls.protocol)
        for protocol in protocols:
            if protocol in flavour_registry:
                raise ValueError(f"protocol {protocol!r} already registered")
            flavour_registry[protocol] = cls


class AbstractFileSystemFlavour(FileSystemFlavourBase):
    __orig_class__ = 'fsspec.spec.AbstractFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = 'abstract'
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        """Turn path from fully-qualified to file-system-specific

        May require FS-specific handling, e.g., for relative paths or links.
        """
        if isinstance(path, list):
            return [cls._strip_protocol(p) for p in path]
        path = stringify_path(path)
        protos = (cls.protocol,) if isinstance(cls.protocol, str) else cls.protocol
        for protocol in protos:
            if path.startswith(protocol + "://"):
                path = path[len(protocol) + 3 :]
            elif path.startswith(protocol + "::"):
                path = path[len(protocol) + 2 :]
        path = path.rstrip("/")
        # use of root_marker to make minimum required path, e.g., "/"
        return path or cls.root_marker

    @staticmethod
    def _get_kwargs_from_urls(path):
        """If kwargs can be encoded in the paths, extract them here

        This should happen before instantiation of the class; incoming paths
        then should be amended to strip the options in methods.

        Examples may look like an sftp path "sftp://user@host:/my/path", where
        the user and host should become kwargs and later get stripped.
        """
        # by default, nothing happens
        return {}


class AzureBlobFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'adlfs.spec.AzureBlobFileSystem'
    __orig_version__ = '2024.1.0'
    protocol = ('abfs', 'az', 'abfss')
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path: str):
        """
        Remove the protocol from the input path

        Parameters
        ----------
        path: str
            Path to remove the protocol from

        Returns
        -------
        str
            Returns a path without the protocol
        """
        if isinstance(path, list):
            return [cls._strip_protocol(p) for p in path]

        STORE_SUFFIX = ".dfs.core.windows.net"
        logger.debug(f"_strip_protocol for {path}")
        if not path.startswith(("abfs://", "az://", "abfss://")):
            path = path.lstrip("/")
            path = "abfs://" + path
        ops = infer_storage_options(path)
        if "username" in ops:
            if ops.get("username", None):
                ops["path"] = ops["username"] + ops["path"]
        # we need to make sure that the path retains
        # the format {host}/{path}
        # here host is the container_name
        elif ops.get("host", None):
            if (
                ops["host"].count(STORE_SUFFIX) == 0
            ):  # no store-suffix, so this is container-name
                ops["path"] = ops["host"] + ops["path"]
        url_query = ops.get("url_query")
        if url_query is not None:
            ops["path"] = f"{ops['path']}?{url_query}"

        logger.debug(f"_strip_protocol({path}) = {ops}")
        stripped_path = ops["path"].lstrip("/")
        return stripped_path

    @staticmethod
    def _get_kwargs_from_urls(urlpath):
        """Get the account_name from the urlpath and pass to storage_options"""
        ops = infer_storage_options(urlpath)
        out = {}
        host: str | None = ops.get("host", None)
        if host:
            match = re.match(
                r"(?P<account_name>.+)\.(dfs|blob)\.core\.windows\.net", host
            )
            if match:
                account_name = match.groupdict()["account_name"]
                out["account_name"] = account_name
        url_query = ops.get("url_query")
        if url_query is not None:
            from urllib.parse import parse_qs

            parsed = parse_qs(url_query)
            if "versionid" in parsed:
                out["version_aware"] = True
        return out


class AzureDatalakeFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'adlfs.gen1.AzureDatalakeFileSystem'
    __orig_version__ = '2024.1.0'
    protocol = ('adl',)
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        ops = infer_storage_options(path)
        return ops["path"]

    @staticmethod
    def _get_kwargs_from_urls(paths):
        """Get the store_name from the urlpath and pass to storage_options"""
        ops = infer_storage_options(paths)
        out = {}
        if ops.get("host", None):
            out["store_name"] = ops["host"]
        return out


class CachingFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.cached.CachingFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('blockcache', 'cached')
    root_marker = ''


class DataFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.data.DataFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('data',)
    root_marker = ''


class DatabricksFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.dbfs.DatabricksFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('dbfs',)
    root_marker = ''


class DirFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.dirfs.DirFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('dir',)
    root_marker = ''


class FTPFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.ftp.FTPFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('ftp',)
    root_marker = '/'

    @classmethod
    def _strip_protocol(cls, path):
        return "/" + infer_storage_options(path)["path"].lstrip("/").rstrip("/")

    @staticmethod
    def _get_kwargs_from_urls(urlpath):
        out = infer_storage_options(urlpath)
        out.pop("path", None)
        out.pop("protocol", None)
        return out


class GCSFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'gcsfs.core.GCSFileSystem'
    __orig_version__ = '2023.12.2post1'
    protocol = ('gcs', 'gs')
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        if isinstance(path, list):
            return [cls._strip_protocol(p) for p in path]
        path = stringify_path(path)
        protos = (cls.protocol,) if isinstance(cls.protocol, str) else cls.protocol
        for protocol in protos:
            if path.startswith(protocol + "://"):
                path = path[len(protocol) + 3 :]
            elif path.startswith(protocol + "::"):
                path = path[len(protocol) + 2 :]
        # use of root_marker to make minimum required path, e.g., "/"
        return path or cls.root_marker

    @classmethod
    def _get_kwargs_from_urls(cls, path):
        _, _, generation = cls._split_path(path, version_aware=True)
        if generation is not None:
            return {"version_aware": True}
        return {}

    @classmethod
    def _split_path(cls, path, version_aware=False):
        """
        Normalise GCS path string into bucket and key.

        Parameters
        ----------
        path : string
            Input path, like `gcs://mybucket/path/to/file`.
            Path is of the form: '[gs|gcs://]bucket[/key][?querystring][#fragment]'

        GCS allows object generation (object version) to be specified in either
        the URL fragment or the `generation` query parameter. When provided,
        the fragment will take priority over the `generation` query paramenter.

        Returns
        -------
            (bucket, key, generation) tuple
        """
        path = cls._strip_protocol(path).lstrip("/")
        if "/" not in path:
            return path, "", None
        bucket, keypart = path.split("/", 1)
        key = keypart
        generation = None
        if version_aware:
            parts = urlsplit(keypart)
            try:
                if parts.fragment:
                    generation = parts.fragment
                elif parts.query:
                    parsed = parse_qs(parts.query)
                    if "generation" in parsed:
                        generation = parsed["generation"][0]
                # Sanity check whether this could be a valid generation ID. If
                # it is not, assume that # or ? characters are supposed to be
                # part of the object name.
                if generation is not None:
                    int(generation)
                    key = parts.path
            except ValueError:
                generation = None
        return (
            bucket,
            key,
            generation,
        )


class GenericFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.generic.GenericFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('generic',)
    root_marker = ''


class GithubFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.github.GithubFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('github',)
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        opts = infer_storage_options(path)
        if "username" not in opts:
            return super()._strip_protocol(path)
        return opts["path"].lstrip("/")

    @staticmethod
    def _get_kwargs_from_urls(path):
        opts = infer_storage_options(path)
        if "username" not in opts:
            return {}
        out = {"org": opts["username"], "repo": opts["password"]}
        if opts["host"]:
            out["sha"] = opts["host"]
        return out


class HTTPFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.http.HTTPFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('http', 'https')
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        """For HTTP, we always want to keep the full URL"""
        return path


class HadoopFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.arrow.HadoopFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('hdfs', 'arrow_hdfs')
    root_marker = '/'

    @classmethod
    def _strip_protocol(cls, path):
        ops = infer_storage_options(path)
        path = ops["path"]
        if path.startswith("//"):
            # special case for "hdfs://path" (without the triple slash)
            path = path[1:]
        return path

    @staticmethod
    def _get_kwargs_from_urls(path):
        ops = infer_storage_options(path)
        out = {}
        if ops.get("host", None):
            out["host"] = ops["host"]
        if ops.get("username", None):
            out["user"] = ops["username"]
        if ops.get("port", None):
            out["port"] = ops["port"]
        if ops.get("url_query", None):
            queries = parse_qs(ops["url_query"])
            if queries.get("replication", None):
                out["replication"] = int(queries["replication"][0])
        return out


class JupyterFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.jupyter.JupyterFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('jupyter', 'jlab')
    root_marker = ''


class LocalFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.local.LocalFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('file', 'local')
    root_marker = '/'

    @classmethod
    def _strip_protocol(cls, path):
        path = stringify_path(path)
        if path.startswith("file://"):
            path = path[7:]
        elif path.startswith("file:"):
            path = path[5:]
        elif path.startswith("local://"):
            path = path[8:]
        elif path.startswith("local:"):
            path = path[6:]
        return make_path_posix(path).rstrip("/") or cls.root_marker


class MemoryFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.memory.MemoryFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('memory',)
    root_marker = '/'

    @classmethod
    def _strip_protocol(cls, path):
        if path.startswith("memory://"):
            path = path[len("memory://") :]
        if "::" in path or "://" in path:
            return path.rstrip("/")
        path = path.lstrip("/").rstrip("/")
        return "/" + path if path else ""


class ReferenceFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.reference.ReferenceFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('reference',)
    root_marker = ''


class S3FileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 's3fs.core.S3FileSystem'
    __orig_version__ = '2023.12.2'
    protocol = ('s3', 's3a')
    root_marker = ''

    @staticmethod
    def _get_kwargs_from_urls(urlpath):
        """
        When we have a urlpath that contains a ?versionId=

        Assume that we want to use version_aware mode for
        the filesystem.
        """
        url_storage_opts = infer_storage_options(urlpath)
        url_query = url_storage_opts.get("url_query")
        out = {}
        if url_query is not None:
            from urllib.parse import parse_qs

            parsed = parse_qs(url_query)
            if "versionId" in parsed:
                out["version_aware"] = True
        return out


class SimpleCacheFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.cached.SimpleCacheFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('simplecache',)
    root_marker = ''


class TarFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.tar.TarFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('tar',)
    root_marker = ''


class WebHDFSFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.webhdfs.WebHDFS'
    __orig_version__ = '2024.2.0'
    protocol = ('webhdfs', 'webHDFS')
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        return infer_storage_options(path)["path"]

    @staticmethod
    def _get_kwargs_from_urls(urlpath):
        out = infer_storage_options(urlpath)
        out.pop("path", None)
        out.pop("protocol", None)
        if "username" in out:
            out["user"] = out.pop("username")
        return out


class WebdavFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'webdav4.fsspec.WebdavFileSystem'
    __orig_version__ = '0.9.8'
    protocol = ('webdav', 'dav')
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path: str) -> str:
        """Strips protocol from the given path, overriding for type-casting."""
        stripped = super()._strip_protocol(path)
        return cast(str, stripped)


class WholeFileCacheFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.cached.WholeFileCacheFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('filecache',)
    root_marker = ''


class ZipFileSystemFlavour(AbstractFileSystemFlavour):
    __orig_class__ = 'fsspec.implementations.zip.ZipFileSystem'
    __orig_version__ = '2024.2.0'
    protocol = ('zip',)
    root_marker = ''

    @classmethod
    def _strip_protocol(cls, path):
        # zip file paths are always relative to the archive root
        return super()._strip_protocol(path).lstrip("/")
